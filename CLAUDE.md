# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Important: Use GitHub Issues for Planning

**All planning and work tracking is done via GitHub Issues.** Do not use PLAN.md for tracking work.

**When planning new work:**
- Search existing issues: `gh issue list --repo gabb-software/gabb-cli`
- Reference relevant issues when discussing implementation approach
- Create new issues for work not already captured

**Issue Labels:**
- `phase: mvp` - Core MVP features
- `phase: performance` - Multi-threaded indexing, VFS, optimization
- `phase: testing` - Testing infrastructure and benchmarks
- `phase: languages` - Multi-language parser support
- `phase: daemon` - Daemon lifecycle and management
- `phase: mcp` - MCP server features
- `phase: distribution` - Binary distribution and packaging
- `phase: documentation` - User and developer documentation
- `phase: large-codebase` - Features for very large codebases (5M+ LOC)
- `priority: high/medium/low` - Priority levels

** ⚠️ Important when implementing features that may impact MCP performance:**

Refer to the [Hypothesis Driven Development](HYPOTHESIS_DRIVEN_DEVELOPMENT.md) guide.

For all other features:
- Reference the issue number in commits (e.g., "Fix #42")
- Close issues when work is complete
- Add implementation notes as issue comments

## Definition of Done

A feature or change is not complete until ALL of the following are satisfied:

1. **Code works** - Implementation is functional and handles edge cases
2. **Tests pass** - `cargo test` passes
3. **Linting passes** - `cargo clippy --all-targets --all-features` has no warnings
4. **Formatting passes** - `cargo fmt --check` passes
5. **Documentation updated** - All relevant docs reflect the changes (see checklist below)

A feature which may impact MCP performance also requires the following to be satisfied:

1. **SWE-bench target improves** - the SWE target must improve, and the improvement must be in line with the hypothesis
2. **SWE-control unaffected** - the SWE control must not be materially affected
3. **SWE-bench lite does not regress** - a broad set of SWE lite tasks must not regress, or the regression should be
acceptable given the improvement

## Important: Keep Documentation Updated

When making changes that affect how tools are used or what options they expose, you **MUST** update all relevant documentation:

### MCP Tool Changes
When modifying MCP tool parameters, descriptions, or behavior in `src/mcp.rs`:
1. **README.md** - Update the MCP tools table and any usage examples
2. **`.claude/skills/gabb/SKILL.md`** - Update the skill file if it exists (describes when/how to use gabb tools)
3. **`src/main.rs` embedded SKILL.md template** - Update the template generated by `gabb init --skill` (search for `gabb-code-navigation` in main.rs)
4. **`.claude/commands/gabb.md`** - Update if the slash command references affected tools
5. **GitHub Issues** - Close related issues when work is complete

### CLI Command Changes
When modifying CLI command options or behavior:
1. **README.md** - Update command examples and options
2. **CLAUDE.md** - Update the "Query Commands" section if affected

### Language Support Changes
When adding a new language parser or modifying supported file extensions in `src/languages/`:
1. **`assets/SKILL.md`** - Update the "Supported Languages" table with new language/extensions
2. **`.claude/skills/gabb/SKILL.md`** - Update the local skill file's language table
3. **README.md** - Update any language support mentions
4. **CLAUDE.md** - Update the "Language Parsers" list in Architecture Overview if adding a new parser

### What Triggers Documentation Updates
- Adding/removing/renaming tool parameters
- Changing parameter types or defaults
- Updating tool descriptions
- Adding new tools or commands
- Changing output formats
- Modifying filtering or search behavior
- Adding new language parsers or file extensions

### Documentation Checklist
Before committing changes to `src/mcp.rs`, CLI commands, or `src/languages/`, verify:
- [ ] README.md reflects current tool/command capabilities
- [ ] Skill file (if exists) describes current tool behavior
- [ ] `assets/SKILL.md` template is updated (for `gabb init --skill`)
- [ ] Generated command files are regenerated if templates changed
- [ ] Supported Languages table is current (if language parser changed)
- [ ] Related GitHub issues are closed or updated

## Releasing

Releases are triggered by changes to `version.toml`. CI runs on every push.

### How Versioning Works

- **Major/Minor/Patch**: All manually controlled in `version.toml`
- **Full version**: `{major}.{minor}.{patch}` (e.g., `0.10.1`)

The `Cargo.toml` version is a placeholder (`0.0.0-dev`) - CI patches it during build.

### Creating a Release

Edit `version.toml` to set the new version:

```toml
major = 0
minor = 10
patch = 1
```

Then commit and push:

```bash
git add version.toml
git commit -m "chore: release v0.10.1"
git push origin main
```

The release workflow triggers automatically when `version.toml` changes.

### What CI/Release Does

**CI workflow** (every push):
1. Runs tests on Ubuntu and macOS
2. Runs linting (rustfmt, clippy)

**Release workflow** (when `version.toml` changes):
1. Runs full CI (tests + linting)
2. Builds binaries for all platforms (macOS x86_64/arm64/universal, Linux musl, Windows)
3. Creates git tag and GitHub release
4. Updates Homebrew tap and Scoop bucket

## Commands

### Build and Run
```bash
# Build the project
cargo build

# Run the daemon (from project root to index)
cargo run -- daemon start --workspace . --db .gabb/index.db

# Run with rebuild flag to delete and recreate index
cargo run -- daemon start --workspace . --db .gabb/index.db --rebuild

# Run with verbose logging
cargo run -- daemon start --workspace . --db .gabb/index.db -v  # verbose
cargo run -- daemon start --workspace . --db .gabb/index.db -vv # very verbose
```

### Development and Testing
```bash
# Format code
cargo fmt

# Run linter
cargo clippy --all-targets --all-features

# Run all tests
cargo test

# Run a specific test
cargo test test_name

# Run tests with output
cargo test -- --nocapture

# Generate documentation
cargo doc --open
```

### Query Commands
```bash
# List all symbols
cargo run -- symbols --db .gabb/index.db

# Find symbol by name
cargo run -- symbol --db .gabb/index.db --name <symbol_name>

# Go to definition at position
cargo run -- definition --db .gabb/index.db --file path/to/file.ts:10:5

# Find implementations at position
cargo run -- implementation --db .gabb/index.db --file path/to/file.ts --line 10 --character 5

# Find usages of symbol at position
cargo run -- usages --db .gabb/index.db --file path/to/file.ts:10:5

# All commands support --json for machine-readable output
cargo run -- --json symbols --db .gabb/index.db
```

## Architecture Overview

Gabb is a local code indexing CLI that builds and maintains a SQLite database of code symbols. It provides fast, offline symbol search and navigation without sending code to remote services.

### Core Components

- **CLI Layer** (`src/main.rs`): Entry point handling command parsing and dispatch. Supports daemon mode and query commands (symbols, symbol, definition, implementation, usages).

- **Daemon** (`src/daemon.rs`): File system watcher using `notify` crate that maintains index freshness. Performs initial full index then incrementally updates on file changes.

- **Indexer** (`src/indexer.rs`): Orchestrates parsing across workspace. Handles full indexing and single-file updates, delegating to language-specific parsers.

- **Language Parsers** (`src/languages/`):
  - `typescript.rs`: TypeScript/TSX parser (`.ts`, `.tsx`)
  - `rust.rs`: Rust parser (`.rs`)
  - `kotlin.rs`: Kotlin parser (`.kt`, `.kts`)
  - `cpp.rs`: C++ parser (`.cpp`, `.cc`, `.cxx`, `.c++`, `.hpp`, `.hh`, `.hxx`, `.h++`)
  - `python.rs`: Python parser (`.py`, `.pyi`)

- **Store** (`src/store.rs`): SQLite persistence layer with WAL mode for concurrent reads. Schema includes:
  - `files`: tracked file metadata (path, hash, mtime)
  - `symbols`: symbol definitions with qualified names and visibility
  - `edges`: relationships between symbols (implements, extends, trait_impl)
  - `refs`: symbol references/usages

### Key Data Flow

1. **Indexing**: File → Parser → Symbol/Edge/Reference Records → SQLite Store
2. **Querying**: Position/Name → Store Lookup → Symbol Resolution → Formatted Output
3. **Incremental Updates**: File Change Event → Re-parse Single File → Update Store

### Symbol Resolution Strategy

- Position-based queries first find symbol at cursor location
- Implementation search follows recorded edges (implements/extends/trait_impl)
- Falls back to name-based matching when no edges exist
- Usages search uses recorded references, falls back to workspace-wide name scan

### Database Location

Default: `.gabb/index.db` (relative to workspace root)
Configurable via `--db` flag on all commands

## Benchmark Analysis

When analyzing benchmark results, refer to:
- **[Results Analysis Guide](benchmark/claude-code/RESULTS_ANALYSIS_GUIDE.md)** - How to interpret results, read transcripts from `~/.claude`, and summarize findings
- **[Benchmark README](benchmark/README.md)** - Overview of API and Claude Code benchmarks
- **[Telemetry README](benchmark/telemetry/README.md)** - Transcript analysis tools

Key locations:
- Results JSON: `benchmark/claude-code/results/*.json`
- Claude transcripts: `~/.claude/projects/{workspace-path}/*.jsonl`
- Current summary: `benchmark/claude-code/README.md`